#pragma config(Sensor, S1,     ts,             sensorEV3_Touch)
#pragma config(Sensor, S2,     gs,             sensorEV3_Gyro)
#pragma config(Sensor, S3,     cs,             sensorEV3_Color)
#pragma config(Sensor, S4,     ss,             sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          lm,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define Black 1
#define Blue 2
#define Green 3
#define Yellow 4
#define Red 5
#define White 6
#define Brown 7

int color, finish_line, speed=30, half_speed=15, start_val=0;
int count_black=0, check=1;
float t;

void go(int speed)
{
	setMotorSpeed(lm,speed);
	setMotorSpeed(rm,speed);
}

void sound()
{
	playSound(soundBeepBeep);
	sleep(1000);
}

void encoder_go(float dist, int speed)
{
	int encoder=(int)(360.0 * dist / 17.58);
	resetMotorEncoder(lm);
	while(getMotorEncoder(lm)<encoder)
	{
		setMotorSpeed(lm,speed);
		setMotorSpeed(rm,speed);
	}
}

void encoder_go_back(float dist, int speed)
{
	int encoder=(int)(360.0 * dist / 17.58);
	resetMotorEncoder(lm);
	resetMotorEncoder(rm);
	setMotorTarget(lm, -encoder, -speed);
	setMotorTarget(rm, -encoder, -speed);
	waitUntilMotorStop(lm);
}

void point_turn(int speed)
{
	int i=getGyroDegrees(gs);
	while(getGyroDegrees(gs)<=(i+90))
	{
		setMotorSpeed(lm,speed);
		setMotorSpeed(rm,-speed);
	}
}

task main()
{
	while(getTouchValue(ts)==0){}
	while(getTouchValue(ts)==1){}
	while(1)
	{
		color=getColorName(cs);
		go(speed);
		if(!start_val && (color != White))
		{
			clearTimer(T1);
			finish_line=color;
			setLEDColor(ledGreen);
			if(color == 1)
			{
				count_black++;
			}
			while(color != White)
			{
				color=getColorName(cs);//must be used. update the color
				go(speed);
			}
				start_val++;
		}

		if(color == finish_line || count_black == 10)
		{
			go(0);
			t=time1[T1];
			displayBigTextLine(1, "record = %.2f sec",t/1000);
			sleep(5000);
			break;
		}

		if(color == 1) //black
		{
			count_black++;
			while(color == 1)//검정줄 수를 반복해서 세는걸 방지
			{
				color = getColorName(cs);
				go(speed);
			}
		}

		if(color == 2) //blue
		{
			if(count_black==0)
			{
				sound();
			}
			else
			{
				for(int i=0;i<count_black;i++)
				{
					sound();
				}
			}
			while(color == 2)
			{
				color = getColorName(cs);
				go(speed);
			}
		}

		if(color == 5) //red
		{
			point_turn(half_speed);
			encoder_go(count_black*10,half_speed);
			point_turn(half_speed);
		}

		if(getUSDistance(ss)<50 && check)
		{
			sound();
			speed=half_speed;
			check=0;
		}
		if(getUSDistance(ss)>=50)
		{
			speed=half_speed*2;
			check=1;
		}

		if(getUSDistance(ss)<10)
		{
			encoder_go_back(20,half_speed);
			point_turn(half_speed);
			encoder_go(count_black*10,half_speed);
			point_turn(half_speed);
		}
	}
}
